# 2. Uber : LLD+HLD

## 0. Clarifications

* **Location Representation:** (x,y) coordinates
  * Distance b/w 2 two points (x1, y1) and(x2, y2) is sqrt((x1-x2)^2 + (y1-y2)^2)
* **Radius**: The system has decided upon max Radius(configurable ofc) a driver has to travel to pickup a rider
* **Cab Sharing Allowed? **=> assume NO: a cab has only 1 rider
* **Types of Cabs: **UberX, UberGo, UberSUV => assume single type for now?

## 1.1 Functional Requirements

* Rider Side
  * Register
  * see locations of nearby cabs before booking
  * request a ride
  * get ETA for driver(before trip starts)
  * get ETA for destination(once in trip)
  * get history of previous trips
  * rate the driver/cab
* Driver/Cab Side
  * Register
  * can switch on/off his availability
  * Receive a trip request from rider
  * see riders location (upon accepting trip request)
  * can see destination
  * mark the trip as complete
  * get history of previous trips
  * rate the users

## 1.2 Non-Functional Requirements



## 2. APIs : HLD



## 3. Estimations : HLD



## 4. LLD Design + Code

### 4.1 Entities/Data Models

```

Cab (/Driver)
------------ id : int, PK
------------ driver_name : str
------------ is_available : bool
------------ trips[] : Trip
------------ license_number : str
------------? model/Cab_Type : Enum(UBER_X, UBER_GO, UBER_SUV)
------------? ratings : Rating

Rider
------------ id : int, PK
------------ name : str
------------ trips[] : Trip

Location
------------ X_Cordinate :float
------------ Y_Cordinate :float
------------ distance() -> float 

Trip
------------ id : int, PK
------------ rider : Rider
------------ cab : Cab
------------ trip_status : ENUM(NOT_STARTED, IN_PROGRESS, ENDED, CANCELLED, REFUND_IN_PROGRESS, ...)
------------ pickup_location : Location
------------ drop_location : Location
------------ start_time : timestamp
------------ end_time : timestamp
------------? payment_status
------------ end_trip() -> None #can be trigerred by driver only

>> Trip_Status (Enum) 
------------ NOT_STARTED, IN_PROGRESS, ENDED, CANCELLED, REFUND_IN_PROGRESS, ...

>> Cab_Type (Enum)
------------ UBER_X, UBER_GO, UBER_SUV..
```

### 4.2 Controllers

```
CabsManager    
------------ cabs_list[]   # all the cabs in Uber system
------------ create_cab()  # onboard a new cab in system
------------ get_cab()     # print a cab 
------------ update_cab_location()
------------ update_cab_availability()
------------ book_cab()    # âœ… if available & inside Radius

RidersManager    
------------ riders_list[]      # list of all regiestered riders in Uber System
------------ creater_rider()    # onboard a rider in system
------------ get_rider()        # print a rider

TripsManager    
------------ trips_list : {Rider->Trips[]}
------------ MAX_ALLOWED_TRIP_MATCHING_RADIUS ()= 10km)
------------ cabs_manager: CabsManager
------------ riders_manager: RidersManager
------------ cab_matching_strategy: CabMatchingStrategy
------------ pricing_strategy: PricingStrategy

------------ create_trip(rider: Rider, pickup_location: Location, drop_location: Location)  # find suitable cab & book/not-book
------------ end_trip(cab: Cab)
------------ get_rider_trips_history()
------------? get_cab_trips_history() # need another set like 'trips_list'??

[Strategies] ====================================================

CabMatchingStrategy(ABC)    # its an interface
@abstractmethod
------------ match_cab_to_rider(rider: Rider, candidate_cabs: List[Cabs], pickup_location: Location, drop_location: Location)

DefaultMatchingStrategy(CabMatchingStrategy)    # can be other logics in future
------------ match_cab_to_rider(rider: Rider, candidate_cabs: List[Cabs], pickup_location: Location, drop_location: Location)


PricingStrategy(ABC)    # its an interface
@abstractmethod
------------ find_price(pickup_location: Location, drop_location: Location)

DefaultPricingStrategy(PricingStrategy)    # can be other logics in future
------------ find_price(pickup_location: Location, drop_location: Location)

```

### 4.3 Code

```python
from abc import ABC, abstractmethod
from enum import Enum
import uuid
import time
import math


# Enums =============================================================
class Cab_Model(Enum):
    UBER_GO = "UBER_GO"
    UBER_XL = "UBER_XL"
    UBER_SUV = "UBER_SUV"


class Trip_Status(Enum):
    NOT_STARTED = "NOT_STARTED"
    IN_PROGRESS = "IN_PROGRESS"
    ENDED = "ENDED"
    CANCELLED = "CANCELLED"


# Exceptions =============================================================
class NoCabsAvailableException(Exception):
    pass


# Models =================================================================
class Cab:
    def __init__(self, driver_name: str, cab_type=Cab_Model.UBER_GO,cab_location = None, current_trip = None, is_available=True):
        self.id = uuid.uuid4()
        self.driver_name = driver_name
        self.cab_type = cab_type
        self.is_available = is_available
        self.location = cab_location
        self.current_trip = current_trip
        self.trips = []
        #self.ratings = []

class Rider:
    def __init__(self, rider_name: str, email: str = ''):
        self.id = uuid.uuid4()
        self.rider_name = rider_name
        self.email = email
        self.trips = []

class Location:
    def __init__(self, x_cordinate: float, y_cordinate: floa):
        self.x_cordinate = x_cordinate
        self.y_cordinate = y_cordinate

class Trip:
    def __init__(self, rider: Rider, cab: Cab, trip_status:Trip_Status.IN_PROGRESS, pickup_location : Location, drop_location: Location, start_time = time.time()):
        self.id = uuid.uuid4()
        self.rider = rider
        self.cab = cab
        self.trip_status = Trip_Status.IN_PROGRESS
        self.pickup_location = pickup_location
        self.drop_location = drop_location
        self.start_time = start_time
    
    def end_trip(self):
        self.trip_status = Trip_Status.ENDED

# Strategies==============================================================

class CabMatchingStrategy(ABC):    # its an interface
    @abstractmethod
    def match_cab_to_rider(self,rider: Rider, candidate_cabs: list[Cab], pickup_location: Location, drop_location: Location) ->Cab:
        pass

class DefaultMatchingStrategy(CabMatchingStrategy):    # can be other logics in future
    def match_cab_to_rider(self,rider: Rider, candidate_cabs: list[Cab], pickup_location: Location, drop_location: Location) -> Cab:
        if len(candidate_cabs) > 0:
            return candidate_cabs[0]
        return None

# util

def distance_computer(A,B):
    return math.sqrt(A**2 + B**2)

class PricingStrategy(ABC):    # its an interface
    @abstractmethod
    def find_price(sefl,pickup_location: Location, drop_location: Location):
        pass

class DefaultPricingStrategy(PricingStrategy):    # can be other logics in future
    
    tarrifs = dict()    # model -> (rate, unit)
    tarrifs[Cab_Model.UBER_GO] = (100,3600) # per hour
    tarrifs[Cab_Model.UBER_XL] = (150,3600) # per hour
    tarrifs[Cab_Model.UBER_SUV] = (200,3600) # per hour
    
    def find_price(self,pickup_location: Location, drop_location: Location, cab: Cab):
        distance_traversed =  distance_computer(pickup_location,drop_location)
        
        tarrif_rate,tarrif_atomic_unit = DefaultPricingStrategy.tarrifs[cab.cab_type]
        
        distance_units = distance_traversed/tarrif_atomic_unit
        
        fare= tarrif_rate*distance_units
        return fare



# Controllers ============================================================

class CabsManager:
    def __init__(self):
        self.cabs_list = dict() # cab_id -> cab

    def create_cab(self,cab:Cab):
        self.cabs_list[cab.id] = cab
        # if esits, handle/throw err
        
    def get_cab(self,cab_id):
        if cab_id not in self.cabs_list.keys():
            print('ERR: cab not regiestered')
            return
        return self.cabs_list[cab_id]
    
    def update_cab_location(self,cab:Cab,new_location: Location):
        if cab.id not in self.cabs_list.keys():
            print('ERR: cab not regiestered')
            return
        self.cabs_list[cab.id].location = new_location
                
    def update_cab_availability(self, cab:Cab, availability: bool):
        if cab.id not in self.cabs_list.keys():
            print('ERR: cab not regiestered')
            return
        self.cabs_list[cab.id].is_available = availability
        
    # âœ… returns all available cabs withing radius
    def get_close_by_cabs(self, location: Location, radius):
        res = []
        for cab in self.cabs_list.values():
            if cab.is_available and distance_computer(cab.location, location) <= radius:
                res.append(cab)
        if len(res) == 0:
            raise NoCabsAvailableException
        return resturn res

class RidersManager:
    def __init__(self):
        self.riders_list = dict() #id ->rider

    def create_rider(self,rider:Rider):
        self.riders_list[rider.id] = rider
        # if esits, handle/throw err
       
    def get_rider(self,rider_id):
        if rider_id not in self.riders_list.keys(): 
            print('ERR: rider not regiestered')
            return
        return self.riders_list[rider_id]

#ðŸŸ¢main driver class
# NOTE: could be splitted for Single Responsibility
class TripsManager:
    
    MAX_ALLOWED_TRIP_MATCHING_DISTANCE = 10
    
    def __init__(self):
        self.trips_list = dict()    # rider_id->Trip
        self.cabs_manager = CabsManager()        
        self.riders_manager = RidersManager()        
        self.cab_matching_strategy = CabMatchingStrategy()        
        self.pricing_strategy = PricingStrategy()     
    
    def create_trip(self, rider: Rider, cab: Cab, pickup_location: Location, drop_location : Location):
        
        # find the ride
        list_available_cabs = self.cabs_manager.get_close_by_cabs(pickup_location)
        matched_cab = self.cab_matching_strategy.match_cab_to_rider(rider, list_available_cabs, pickup_location, drop_location)
        
        # compute the fare
        fare = self.pricing_strategy.find_price(pickup_location, drop_location)
        
        # create trip
        new_trip = Trip(rider= rider, cab = matched_cab, pickup_location=pickup_location, drop_location = drop_location, start_time=time.time())
        self.trips_list[rider.id] = new_trip
        return new_trip
        
    
    def end_trip(self, cab: Cab):
        if cab.current_trip:
            cab.current_trip.end_trip()
            cab.current_trip = None
    
    def get_riders_trip_history(self,rider:Rider):
        rider_id = rider.id
        return self.trips_list.get(rider_id,None)

# **************************** Mock Run******************************
# **************************** UTs **********************************
```







